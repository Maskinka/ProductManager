Вам необходимо реализовать менеджер товаров, который умеет:
1. Добавлять товары в репозиторий
1. Искать товары

Что нужно сделать:
1. Разработайте базовый класс `Product`, содержащий `id`, название, стоимость
1. Разработать два унаследованных от `Product` класса: `Book` (с текстовыми полями название и автор) и `Smartphone` (с текстовыми полями название и производитель); общие поля вынесите в родителя.
1. Разработайте репозиторий, позволяющий сохранять `Product`'ы, получать все сохранённые `Product`'ы и удалять по `id`.
1. Разработайте менеджера, который умеет добавлять `Product`'ы в репозиторий и осуществлять поиск по ним. 

Менеджер при переборе всех продуктов, хранящихся в репозитории, должен для каждого продукта вызывать определённый в классе менеджера же метод `matches`, который проверяет, соответствует ли продукт поисковому запросу.

При проверке на соответствие запросу товару мы проверяем вхождение запроса в текст названия товара.

Напишите тесты на менеджер и репозиторий, добившись 100% покрытия по бранчам методов с логикой.

# Задание 2. Менеджер Товаров (Rich Model)

1. Создайте в том же что и первое задание репозитории новую ветку `rich` на базе ветки первого задания
1. Реализуйте в классе `Product` метод `public boolean matches(String search)`, который определяет, подходит ли продукт поисковому запросу исходя из названия
1. Переопределите этот метод в дочерних классах, чтобы они сначала вызывали родительский метод и только если родительский метод вернул `false`, тогда проводили доп.проверки (`Book` - по автору, `Smartphone` - по производителю).
1. Замените в менеджере вызов метода `matches` из класса самого менеджера на вызов метода `matches` у самих продуктов: `if (product.matches(search)) {`
1. Теперь вам нужны unit-тесты на методы ваших умных моделей (напишите их)
1. Удостоверьтесь, что ранее написанные тесты на менеджера (из решения задачи 1) проходят
1. Добейтесь 100% покрытия по бранчам методов с логикой 

# Задание 3. NotFoundException

Вы решили сделать так, чтобы при попытке удаления несуществующего объекта из репозитория генерировалось ваше исключение, а не `ArrayIndexOfBoundsException`.
Создайте класс исключения `NotFoundException` отнаследовавшись от `RuntimeException` и реализуйте как минимум конструктор с параметром-сообщением. Напишите 2 автотеста на репозиторий: первый должен проверять успешность удаления существующего элемента, второй - генерации `NotFoundException` при попытке удаления несуществующего элемента
Для реализации этой логики вам понадобится добавить метод `findById`, предназначенный для поиска товара в репозитории по его id. 
Убедитесь, что ваши автотесты проходят (напоминаем, что проект должен быть на базе Maven, с подключенными зависимостями и необходимыми плагинами).

# Задание 4. AlreadyExistsException

Добавьте новую функциональность. В методе добавления нового товара в репозиторий должна осуществляться проверка на то, что в нём нет уже товара, у которого бы совпадал `id` с `id` добавляемого товара. Если же такой уже есть, то должно выкидываться ваше исключение - 
`AlreadyExistsException`. 
Напишите 2 автотеста на репозиторий: первый должен проверять успешность добавления элемента, второй - генерации `AlreadyExistsException` при попытке добавить элемент с повторяющимся `id`.
